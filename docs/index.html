<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8" />
    <title>たいら高山～溝口駅南口バス発車時刻</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
        body {
            font-family: 'Noto Sans JP', Arial, sans-serif;
            margin: 1em;
            background: #f8f9fa;
            color: #333;
        }

        .container {
            max-width: 500px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 1.5em;
            padding: 1em;
            background: white;
            border-radius: 1em;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .title {
            font-size: 1.3em;
            margin-bottom: 0.5em;
            font-weight: bold;
            color: #1976d2;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: .5em;
        }

        .title-icon {
            width: 1.2em;
            height: 1.2em;
            object-fit: contain;
        }

        .current-time {
            font-size: 1.2em;
            color: #666;
            margin-bottom: .5em;
        }

        .refresh-btn {
            background: #1976d2;
            color: #fff;
            border: none;
            padding: .5em 1em;
            border-radius: .5em;
            cursor: pointer;
            font-size: .9em;
            margin-top: .5em;
        }

        .refresh-btn:hover {
            background: #1565c0;
        }

        .train-box {
            border: 1px solid #ddd;
            border-radius: 1em;
            margin: .8em 0;
            padding: 1.2em;
            background: white;
            box-shadow: 0 2px 5px rgba(0, 0, 0, .05);
            transition: all .3s ease;
        }

        .train-box.compact {
            padding: .6em;
            margin: .4em 0;
        }

        .train-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .train-left {
            flex: 1;
            display: flex;
            align-items: center;
        }

        .departure-time {
            font-size: 1.4em;
            font-weight: bold;
            margin-bottom: .2em;
        }

        .departure-time.compact {
            font-size: 1.2em;
            color: #888;
            margin-bottom: 0;
        }

        .train-type-dest {
            font-size: 1.2em;
            margin-left: .5em;
            font-weight: bold;
        }

        .train-type-dest.compact {
            color: #666;
            font-size: 1.0em;
        }

        .time-remaining {
            text-align: right;
            font-weight: bold;
            min-width: 100px;
        }

        .soon {
            color: #888;
            font-size: 1.2em;
        }

        .normal {
            color: #d32f2f;
            font-size: 1.6em;
        }

        .later {
            color: #222;
            font-size: 1.6em;
        }

        .train-icon {
            width: 24px;
            height: 24px;
            margin-right: .8em;
            flex-shrink: 0;
            object-fit: contain;
        }

        .loading {
            text-align: center;
            padding: 2em;
            color: #666;
        }

        .error {
            text-align: center;
            padding: 2em;
            color: #d32f2f;
            background: #ffebee;
            border-radius: 1em;
            margin: 1em 0;
        }

        .footer {
            text-align: center;
            margin-top: 2em;
            padding: 1.2em;
            font-size: .85em;
            color: #777;
            background: white;
            border-top: 1px solid #eee;
            border-radius: 1.2em 1.2em 0 0;
            box-shadow: 0 -3px 8px rgba(0, 0, 0, .05);
            width: 100%;
            box-sizing: border-box;
        }

        .footer a {
            color: #1976d2;
            text-decoration: none;
            font-weight: bold;
            transition: color .2s ease;
        }

        .footer a:hover {
            color: #1565c0;
            text-decoration: underline;
        }

        .express-red {
            color: #d32f2f;
            font-weight: bold;
            text-shadow: 0 0 3px rgba(211, 47, 47, .3);
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <div class="title">
                <img src="icon1.png" alt="Icon1" class="title-icon" onerror="this.style.display='none'">
                たいら高山～溝口駅南口バス発車時刻
            </div>
            <div class="current-time" id="now"></div>
            <button class="refresh-btn" id="refreshBtn">更新</button>
        </div>
        <div id="trains">
            <div class="loading">時刻表を読み込み中...</div>
        </div>
        <div class="footer">
            <a href="https://trafficinfo.westjr.co.jp/kinki.html" target="_blank">近畿エリア 運行情報：JR西日本列車運行情報</a>
        </div>
    </div>

    <!-- =========================
       バスリアルタイム：ロジック（module）
       ========================= -->
    <script type="module">
        // @ts-check
        /** **************************************
         * 0) 設定（ここを環境に合わせて変更してください）
         *****************************************/
        // 静的GTFSの取得先（JSON/CSVのいずれかを想定）
        // A. JSON配列（推奨：手元でCSV→JSONに変換してホスティング）
        const STATIC_JSON = {
            stops: "stops.json",       // [{stop_id,stop_name,...}]
            trips: "trips.json",       // [{trip_id,route_id,trip_headsign,...}]
            routes: "routes.json"       // [{route_id,route_short_name,route_long_name}]
        };
        // B. もしCSVのまま置く場合（簡易CSVパーサを後段に用意）
        const STATIC_CSV = {
            enabled: false,
            stops: "stops.txt",
            trips: "trips.txt",
            stopTimes: "stop_times.txt",
            routes: "routes.txt"
        };

        // GTFS-RT（JSON化された TripUpdate feed を想定）
        // 例：自作の小さなプロキシで protobuf -> JSON にして公開
        const REALTIME_FEED_URL = "realtime_tripupdates.json"; // 例: [{"id":"...","tripUpdate":{...}},...]
        const ORIGIN_STOP_ID = "260_1";
        const DEST_STOP_ID = "434_5";

        const STOP_TIMES_BY_ROUTE_DIR = "stop_times/by_route/";
        const STOP_TIMES_FILE_MIN = 10000;
        const STOP_TIMES_FILE_MAX = 10099;

        // stop_idの表記ゆれがある場合のエイリアス
        /** @type {Record<string,string[]>} */
        const STOP_ID_ALIAS = {
            // 例: "434_5": ["434","434-5"]
        };

        // 何本表示するか
        const MAX_ROWS = 5;

        // 更新間隔
        const UI_REFRESH_MS = 60_000;   // 1分ごと：時計＆カウントダウンだけ更新
        const RT_REFRESH_MS = 300_000;  // 5分ごと：GTFS-RT(JSON)を再取得して再計算

        /** **************************************
         * 1) 型定義（JSDoc：ブラウザでそのまま使える）
         *****************************************/
        /**
         * @typedef {{stop_id:string, stop_name:string}} GtfsStop
         * @typedef {{trip_id:string, route_id:string, trip_headsign?:string, direction_id?:0|1}} GtfsTrip
         * @typedef {{trip_id:string, arrival_time:string, departure_time:string, stop_id:string, stop_sequence:number}} GtfsStopTime
         * @typedef {{route_id:string, route_short_name?:string, route_long_name?:string}} GtfsRoute
         *
         * @typedef {{ time?:number, delay?:number }} RtTime
         * @typedef {{ stopId?:string, stopSequence?:number, arrival?:RtTime, departure?:RtTime, scheduleRelationship?:"SCHEDULED"|"SKIPPED"|"NO_DATA"|"UNSCHEDULED"|"CANCELED"|"ADDED" }} RtStopTimeUpdate
         * @typedef {{ trip:{tripId?:string, routeId?:string, directionId?:number, startDate?:string}, stopTimeUpdate?:RtStopTimeUpdate[], scheduleRelationship?:RtStopTimeUpdate["scheduleRelationship"], timestamp?:number }} RtTripUpdate
         * @typedef {{ entity: { id:string, tripUpdate?:RtTripUpdate }[] }} RtFeed
         *
         * @typedef {{ tripsById:Map<string,GtfsTrip>, routesById:Map<string,GtfsRoute>, stopsById:Map<string,GtfsStop>, stopTimesByTrip:Map<string,GtfsStopTime[]>, stopTimesByStop:Map<string,GtfsStopTime[]> }} StaticIndex
         * @typedef {{ trip_id:string, route_label:string, headsign:string, origin_stop_id:string, dest_stop_id:string, sched_departure:number, live_departure?:number, delay_departure_sec?:number, schedule_relationship?:RtStopTimeUpdate["scheduleRelationship"] }} MergedLeg
         */

        // 直近に突合した結果をキャッシュして、UIだけ毎分再描画
        let staticIndex /** @type {StaticIndex|undefined} */ = undefined;
        let legsCache   /** @type {MergedLeg[]|undefined} */ = undefined;
        let rtMeta      /** @type {{generated_at?: string}|undefined} */ = undefined;

        // ① 初回だけ静的GTFSを読み込み（stops/trips/routes → RT参照して分割stop_times → index化）
        async function ensureStaticIndex() {
            if (staticIndex) return;

            const { stops, trips, routes } = await loadStaticGtfsBase();
            const tripsById = new Map(trips.map(t => [t.trip_id, t]));

            // 先にRTを読み、候補 route_id を抽出（snake_case→camelCase は loadRealtime 内で処理済み）
            const rtForBoot = await loadRealtime();

            // 分割 stop_times を必要なルートだけロード
            const stopTimes = await loadPartitionedStopTimes(rtForBoot, tripsById, ORIGIN_STOP_ID);

            // インデックス化
            staticIndex = buildStaticIndex(stops, trips, stopTimes, routes, STOP_ID_ALIAS);

            // 初回キャッシュ生成
            legsCache = mergeTripUpdatesForOriginToDest(
                staticIndex, rtForBoot, ORIGIN_STOP_ID, DEST_STOP_ID, Math.floor(Date.now() / 1000), STOP_ID_ALIAS
            );
            rtMeta = rtForBoot && 'generated_at' in rtForBoot ? { generated_at: rtForBoot.generated_at } : {};
        }

        // ② 5分ごと：RTを取得して legs を再計算（merge）
        async function refreshData() {
            await ensureStaticIndex();
            const rt = await loadRealtime();
            rtMeta = rt && 'generated_at' in rt ? { generated_at: rt.generated_at } : {};
            legsCache = mergeTripUpdatesForOriginToDest(
                staticIndex, rt, ORIGIN_STOP_ID, DEST_STOP_ID, Math.floor(Date.now() / 1000), STOP_ID_ALIAS
            );
            renderFromCache();
        }

        // ③ 1分ごと：キャッシュからカウントダウン再計算だけして描画
        function renderFromCache() {
            updateCurrentTime();
            if (!legsCache || !legsCache.length) {
                document.getElementById("trains").innerHTML = `<div class="loading">本日以降の便が見つかりません。</div>`;
                return;
            }
            // 既存の renderDepartures を再利用
            renderDepartures(legsCache);

            // 画面のどこかに「RT更新時刻」を出したい場合（任意）
            // 例: ヘッダーの現在時刻の後ろに付ける
            if (rtMeta?.generated_at) {
                const d = new Date(rtMeta.generated_at);
                const hh = String(d.getHours()).padStart(2, '0');
                const mm = String(d.getMinutes()).padStart(2, '0');
                const nowEl = document.getElementById("now");
                nowEl.textContent = nowEl.textContent.replace(/\s*\(RT .*\)$/, "");
                nowEl.textContent += ` (RT ${hh}:${mm} 更新)`;
            }
        }


        /** **************************************
         * 2) ヘルパー
         *****************************************/
        /** HH:MM:SS を秒に（25:10:00 のような24h超えも可） */
        const toSecs = (t) => {
            const [h, m, s] = t.split(":").map(Number);
            return (h * 3600) + (m * 60) + (s || 0);
        };
        /** 秒 → HH:MM（UI表示用） */
        const toHHMM = (secs) => {
            const h = Math.floor(secs / 3600);
            const m = Math.floor((secs % 3600) / 60);
            return `${String(h).padStart(2, "0")}:${String(m).padStart(2, "0")}`;
        };
        /** aliasテーブルから正規化Mapを構築 */
        const buildAliasLookup = (alias) => {
            const m = new Map();
            Object.entries(alias || {}).forEach(([canonical, arr]) => {
                m.set(canonical, canonical);
                arr.forEach(a => m.set(a, canonical));
            });
            return m;
        };
        /** stop_id 正規化 */
        const normalizeStopId = (id, aliasLut) => aliasLut.get(id) ?? id;

        /** **************************************
         * 3) 静的インデックス（いただいたロジックをJSに移植）
         *****************************************/
        /** @param {GtfsStop[]} stops @param {GtfsTrip[]} trips @param {GtfsStopTime[]} stopTimes @param {GtfsRoute[]} routes @param {Record<string,string[]>} [alias] */
        function buildStaticIndex(stops, trips, stopTimes, routes, alias) {
            const aliasLut = buildAliasLookup(alias ?? {});
            const tripsById = new Map(trips.map(t => [t.trip_id, t]));
            const routesById = new Map(routes.map(r => [r.route_id, r]));
            const stopsById = new Map(stops.map(s => [normalizeStopId(s.stop_id, aliasLut), s]));

            const stopTimesByTrip = new Map();
            for (const st of stopTimes) {
                const arr = stopTimesByTrip.get(st.trip_id) ?? [];
                arr.push({ ...st, stop_id: normalizeStopId(st.stop_id, aliasLut) });
                stopTimesByTrip.set(st.trip_id, arr);
            }
            for (const arr of stopTimesByTrip.values()) {
                arr.sort((a, b) => a.stop_sequence - b.stop_sequence);
            }

            const stopTimesByStop = new Map();
            for (const st of stopTimes) {
                const sid = normalizeStopId(st.stop_id, aliasLut);
                const arr = stopTimesByStop.get(sid) ?? [];
                arr.push({ ...st, stop_id: sid });
                stopTimesByStop.set(sid, arr);
            }
            for (const arr of stopTimesByStop.values()) {
                arr.sort((a, b) => {
                    const ta = toSecs(a.departure_time), tb = toSecs(b.departure_time);
                    if (ta !== tb) return ta - tb;
                    return a.trip_id.localeCompare(b.trip_id);
                });
            }

            return { tripsById, routesById, stopsById, stopTimesByTrip, stopTimesByStop };
        }

        /** **************************************
         * 4) 突合＆マージ（いただいたロジックをJSに移植）
         *****************************************/
        /** @param {StaticIndex} idx @param {RtFeed|undefined} rt @param {string} originStopId @param {string} destStopId @param {number} [nowEpochSec] @param {Record<string,string[]>} [alias] */
        function mergeTripUpdatesForOriginToDest(idx, rt, originStopId, destStopId, nowEpochSec = Math.floor(Date.now() / 1000), alias) {
            const aliasLut = buildAliasLookup(alias ?? {});
            const origin = normalizeStopId(originStopId, aliasLut);
            const dest = normalizeStopId(destStopId, aliasLut);
            const out = [];

            const departuresAtOrigin = idx.stopTimesByStop.get(origin) ?? [];

            const rtByTrip = new Map();
            if (rt) {
                for (const e of rt.entity) {
                    const tu = e.tripUpdate;
                    if (tu?.trip?.tripId) rtByTrip.set(tu.trip.tripId, tu);
                }
            }

            for (const st of departuresAtOrigin) {
                const trip = idx.tripsById.get(st.trip_id);
                if (!trip) continue;

                const seqList = idx.stopTimesByTrip.get(st.trip_id) ?? [];
                const originRow = seqList.find(r => r.stop_id === origin && r.stop_sequence === st.stop_sequence)
                    ?? seqList.find(r => r.stop_id === origin);
                if (!originRow) continue;

                const destRow = seqList.find(r => r.stop_id === dest && r.stop_sequence > originRow.stop_sequence);
                if (!destRow) continue;

                const schedDepartureSec = toSecs(originRow.departure_time);
                const route = idx.routesById.get(trip.route_id);
                const base = {
                    trip_id: st.trip_id,
                    route_label: route?.route_short_name || route?.route_long_name || trip.route_id,
                    headsign: trip.trip_headsign || "",
                    origin_stop_id: origin,
                    dest_stop_id: dest,
                    sched_departure: schedDepartureSec
                };

                const tu = rtByTrip.get(st.trip_id);
                if (tu?.stopTimeUpdate?.length) {
                    const originUpdate =
                        tu.stopTimeUpdate.find(u => u.stopSequence === originRow.stop_sequence) ||
                        tu.stopTimeUpdate.find(u => (u.stopId && normalizeStopId(u.stopId, aliasLut) === origin));

                    if (originUpdate) {
                        const dep = originUpdate.departure || originUpdate.arrival;
                        const live = dep?.time;
                        const delay = dep?.delay;
                        base.schedule_relationship = originUpdate.scheduleRelationship ?? tu.scheduleRelationship;

                        if (typeof live === "number") {
                            base.live_departure = live;
                            if (typeof delay === "number") base.delay_departure_sec = delay;
                        } else if (typeof delay === "number") {
                            base.live_departure = Math.max(0, schedDepartureSec + delay);
                            base.delay_departure_sec = delay;
                        }
                    }
                }

                out.push(base);
            }

            out.sort((a, b) => (a.live_departure ?? a.sched_departure) - (b.live_departure ?? b.sched_departure));
            return out;
        }

        /** **************************************
         * RTアダプタ：snake_case → camelCase へ変換（epoch秒の文字列→number）
         *****************************************/
        /**
         * @param {any} rtSnake
         * @returns {RtFeed|undefined}
         */
        function adaptRtSnakeToCamel(rtSnake) {
        if (!rtSnake) return undefined;

        // ODPTの出力例に合わせ、ルートは [{id, trip_update:{...}}] or {entity:[...]} どちらも受ける
        const entities = Array.isArray(rtSnake)
            ? rtSnake
            : (Array.isArray(rtSnake.entity) ? rtSnake.entity : []);

        /** @type {RtFeed} */
        const out = { entity: [] };

        for (const ent of entities) {
            const tuSnake = ent.trip_update || ent.tripUpdate || ent.tripupdate;
            if (!tuSnake) { out.entity.push({ id: String(ent.id || "") }); continue; }

            // trip 部分
            const t = tuSnake.trip || {};
            const trip = {
            tripId: t.trip_id ?? t.tripId,
            routeId: t.route_id ?? t.routeId,
            directionId: t.direction_id ?? t.directionId,
            startDate: t.start_date ?? t.startDate
            };

            // stop_time_update 配列
            const stus = Array.isArray(tuSnake.stop_time_update || tuSnake.stopTimeUpdate)
            ? (tuSnake.stop_time_update || tuSnake.stopTimeUpdate)
            : [];
            const stopTimeUpdate = stus.map(u => {
            // departure.time / arrival.time は epoch秒の"文字列"想定 → number へ
            const dep = u.departure ? {
                time: numOrUndefined(u.departure.time),
                delay: numOrUndefined(u.departure.delay)
            } : undefined;
            const arr = u.arrival ? {
                time: numOrUndefined(u.arrival.time),
                delay: numOrUndefined(u.arrival.delay)
            } : undefined;

            return {
                stopId: u.stop_id ?? u.stopId,
                stopSequence: numOrUndefined(u.stop_sequence ?? u.stopSequence),
                arrival: arr,
                departure: dep,
                scheduleRelationship: u.schedule_relationship ?? u.scheduleRelationship
            };
            });

            /** @type {RtTripUpdate} */
            const tu = {
            trip,
            stopTimeUpdate,
            scheduleRelationship: tuSnake.schedule_relationship ?? tuSnake.scheduleRelationship,
            timestamp: numOrUndefined(tuSnake.timestamp)
            };

            out.entity.push({ id: String(ent.id || ""), tripUpdate: tu });
        }
        return out;

        function numOrUndefined(v) {
            if (v == null) return undefined;
            const n = typeof v === "string" ? Number(v) : (typeof v === "number" ? v : NaN);
            return Number.isFinite(n) ? n : undefined;
        }
        }


        /** **************************************
         * 5) データ取得（JSON優先／CSV fallback）
         *****************************************/
        async function fetchJsonOrCsv(url, isCsv) {
            const res = await fetch(url, { cache: "no-store" });
            if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
            if (!isCsv) return res.json();
            const text = await res.text();
            return parseCsv(text); // 簡易CSVパーサ
        }

        // 超簡易CSVパーサ（カンマ区切り・引用符は軽めの対応）
        function parseCsv(csvText) {
            const lines = csvText.trim().split(/\r?\n/);
            const header = lines[0].split(",").map(s => s.trim());
            return lines.slice(1).map(line => {
                const cols = splitCsvLine(line);
        /** @type {any} */ const row = {};
                header.forEach((h, i) => row[h] = cols[i]);
                // 数値/配列の整形は必要に応じてここで
                if (row.stop_sequence != null) row.stop_sequence = Number(row.stop_sequence);
                return row;
            });
        }
        function splitCsvLine(line) {
            const out = [];
            let cur = "", inQ = false;
            for (let i = 0; i < line.length; i++) {
                const ch = line[i];
                if (ch === '"') {
                    if (inQ && line[i + 1] === '"') { cur += '"'; i++; }
                    else { inQ = !inQ; }
                } else if (ch === "," && !inQ) {
                    out.push(cur); cur = "";
                } else {
                    cur += ch;
                }
            }
            out.push(cur);
            return out.map(s => s.trim());
        }

        async function loadStaticGtfsBase() {
            const useCsv = STATIC_CSV.enabled;
            const stops  = await fetchJsonOrCsv(useCsv ? STATIC_CSV.stops  : STATIC_JSON.stops,  useCsv);
            const trips  = await fetchJsonOrCsv(useCsv ? STATIC_CSV.trips  : STATIC_JSON.trips,  useCsv);
            const routes = await fetchJsonOrCsv(useCsv ? STATIC_CSV.routes : STATIC_JSON.routes, useCsv);
            return /** @type {{stops:GtfsStop[],trips:GtfsTrip[],routes:GtfsRoute[]}} */({ stops, trips, routes });
        }

        async function loadRealtime() {
        try {
            const res = await fetch(REALTIME_FEED_URL, { cache: "no-store" });
            if (!res.ok) return undefined;
            const raw = await res.json();
            // ★変更: snake_case → 既存ロジックが読む camelCase に変換
            return adaptRtSnakeToCamel(raw);
        } catch {
            return undefined;
        }
        }

        /** **************************************
         * 分割 stop_times を「関係する route_id のみ」読む
         * 1) まずRTから route_id を抽出（スリムに）
         * 2) RTが空なら、番号レンジを小刻みに舐め、ORIGIN_STOP_ID を含む便が十分見つかったら停止
         *****************************************/

        /**
         * RTから候補route_idを集める（trip.routeId が無い場合は tripsById で補完）
         * @param {RtFeed|undefined} rt
         * @param {Map<string,GtfsTrip>} tripsById
         */
        function pickRouteIdsFromRt(rt, tripsById) {
        const set = new Set();
        if (!rt) return set;
        for (const e of rt.entity) {
            const t = e.tripUpdate?.trip;
            if (!t) continue;
            let rid = t.routeId;
            if (!rid && t.tripId) rid = tripsById.get(t.tripId)?.route_id;
            if (rid) set.add(String(rid));
        }
        return set;
        }

        /**
         * 指定 route_id の分割ファイルをまとめてロード
         * @param {Iterable<string>} routeIds
         * @returns {Promise<GtfsStopTime[]>}
         */
        async function loadStopTimesByRouteIds(routeIds) {
        const chunks = [];
        for (const routeId of routeIds) {
            const url = `${STOP_TIMES_BY_ROUTE_DIR}${routeId}.json`;
            try {
            const res = await fetch(url, { cache: "no-store" });
            if (!res.ok) continue;
            const arr = await res.json();
            // stop_sequence を number に揃える
            for (const r of arr) if (r.stop_sequence != null) r.stop_sequence = Number(r.stop_sequence);
            chunks.push(arr);
            } catch { /* スキップ */ }
        }
        return chunks.flat();
        }

        /**
         * フォールバック：番号レンジを小刻みに舐めつつ、
         * ORIGIN_STOP_ID を含む出発便が十分集まったら打ち切る
         * @param {string} originStopId
         * @param {Map<string,GtfsTrip>} tripsById
         * @param {number} needCount
         */
        async function loadStopTimesFallback(originStopId, tripsById, needCount = MAX_ROWS + 8) {
        const out = [];
        // まとめ打ちしすぎないように、10ファイルずつ読む
        const STEP = 10;
        for (let start = STOP_TIMES_FILE_MIN; start <= STOP_TIMES_FILE_MAX; start += STEP) {
            const ids = [];
            for (let n = start; n < start + STEP && n <= STOP_TIMES_FILE_MAX; n++) {
            ids.push(String(n));
            }
            const chunk = await loadStopTimesByRouteIds(ids);
            out.push(...chunk);

            // origin を含む便が必要数あるか軽く確認して打ち切る（速度優先のラフ判定）
            const enough = out.some(Boolean) && countDeparturesAtStop(out, originStopId) >= needCount;
            if (enough) break;
        }
        return out;

        function countDeparturesAtStop(stopTimes, stopId) {
            let c = 0;
            for (const st of stopTimes) if (st.stop_id === stopId) c++;
            return c;
        }
        }

        /**
         * 入口関数：stops/trips/routes 取得後に呼び出す
         * RTがあれば候補ルートだけ、無ければレンジから段階的に収集
         * @param {RtFeed|undefined} rt
         * @param {Map<string,GtfsTrip>} tripsById
         * @param {string} originStopId
         */
        async function loadPartitionedStopTimes(rt, tripsById, originStopId) {
        const rtRouteIds = pickRouteIdsFromRt(rt, tripsById);
        if (rtRouteIds.size > 0) {
            return await loadStopTimesByRouteIds(rtRouteIds);
        }
        // RTが空のときはフォールバック
        return await loadStopTimesFallback(originStopId, tripsById);
        }


        /** **************************************
         * 6) UI：現在時刻・アイコン・描画
         *****************************************/
        function getTrainIcon(remainingMinutes) {
            if (remainingMinutes < 10) return 'red.png';
            else if (remainingMinutes < 20) return 'yellow.png';
            else return 'green.png';
        }

        function updateCurrentTime() {
            const now = new Date();
            const week = ["日", "月", "火", "水", "木", "金", "土"];
            const timeString = `${String(now.getHours()).padStart(2, "0")}:${String(now.getMinutes()).padStart(2, "0")}`;
            const dayString = `${week[now.getDay()]}曜日`;
            document.getElementById("now").textContent = `現在時刻: ${timeString} (${dayString})`;
        }

        function toDateTodayFromSecs(secs) {
            const h = Math.floor(secs / 3600);
            const m = Math.floor((secs % 3600) / 60);
            const d = new Date();
            d.setHours(h, m, 0, 0);
            return d;
        }

        /** リスト描画（MAX_ROWS・カウントダウン・色分けを維持） */
        function renderDepartures(legs) {
            const now = new Date();
            const root = document.getElementById("trains");

            // 未来5本を抽出（-5分～4時間の範囲）
            const enriched = legs.map(l => {
                const depSecs = l.live_departure ?? l.sched_departure;
                const depDate = toDateTodayFromSecs(depSecs);
                if (depDate < now) depDate.setDate(depDate.getDate() + 1); // 0時跨ぎ対策
                const diffMin = Math.floor((depDate - now) / 60000);
                return {
                    time: toHHMM(depSecs),
                    type: (l.route_label || "バス"),
                    destination: l.headsign || "",
                    remainingMinutes: diffMin,
                    departureTime: depDate
                };
            }).filter(r => r.remainingMinutes >= -5 && r.remainingMinutes <= 240)
                .sort((a, b) => a.departureTime - b.departureTime)
                .slice(0, MAX_ROWS);

            if (!enriched.length) {
                root.innerHTML = `<div class="loading">本日以降の便が見つかりません。</div>`;
                return;
            }

            const html = enriched.map(train => {
                const isCompact = train.remainingMinutes < 10;
                const iconSrc = getTrainIcon(train.remainingMinutes);
                const compactClass = isCompact ? 'compact' : '';
                const timeClass =
                    train.remainingMinutes < 10 ? 'soon' :
                        (train.remainingMinutes < 20 ? 'normal' : 'later');

                return `
          <div class="train-box ${compactClass}">
            <div class="train-info">
              <div class="train-left">
                <img src="${iconSrc}" alt="Bus Status" class="train-icon" onerror="this.style.display='none'">
                <span class="departure-time ${compactClass}">${train.time}</span>
                <span class="train-type-dest ${compactClass}">${train.type} ${train.destination}</span>
              </div>
              <div class="time-remaining ${timeClass}">
                あと${train.remainingMinutes}分
              </div>
            </div>
          </div>
        `;
            }).join("");

            root.innerHTML = html;
        }

        /** **************************************
         * 7) メインフロー
         *****************************************/

        async function loadAndRender() {
            try {
                updateCurrentTime();
                await ensureStaticIndex();  // 初回構築のみ
                renderFromCache();          // キャッシュから描画
            } catch (err) {
                document.getElementById("trains").innerHTML =
                '<div class="error">時刻表データの取得または処理に失敗しました。<br>設定やデータ形式をご確認ください。</div>';
            }
        }

        // 初期表示 & ボタン/タイマー
        document.getElementById("refreshBtn").addEventListener("click", loadAndRender);
        loadAndRender();
        setInterval(loadAndRender, 60_000);

        // 初期表示：まずデータを取りに行き、その後はUIだけ1分ごと更新
        await refreshData();            // 起動時に一度データ取得＆描画
        alignToMinute(renderFromCache); // 以後は毎分UIだけ更新
        setInterval(refreshData, RT_REFRESH_MS); // 5分ごとにデータ再取得

        // 「ちょうど00秒」に揃えてから毎分実行するヘルパ
        function alignToMinute(fn) {
            const now = Date.now();
            const msToNextMinute = 60_000 - (now % 60_000);
            setTimeout(() => {
                fn();
                setInterval(fn, UI_REFRESH_MS);
            }, msToNextMinute);
        }

        // 更新ボタンは「即時データ再取得」に割り当て
        document.getElementById("refreshBtn").addEventListener("click", () => {
            refreshData().catch(() => {/* 失敗時は前回キャッシュで継続 */ });
        });

    </script>
</body>

</html>